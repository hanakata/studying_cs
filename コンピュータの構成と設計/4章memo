4章プロセッサ

■論理設計とクロック方式
コンピュータ設計を検討するにはマシンを実装するハードウエア論理回路の動作方式と
マシンのクロックの刻み方を決める必要がある。
MIPSのデータパスユニットの論理要素
・状態を記憶する要素
・組み合わせ論理要素＝データの値に何らかの操作を行う
クロック方式＝信号がいつ読み出し可能でいつ書き込み可能かを定義する※重要
論理的に高い信号＝アサートされた
論理的に高く設定＝アサートする
論理的に低い信号＝ネゲートされた
論理的に低く設定＝ネゲートする
今回の説明ではクロック方式としてエッジトリガ方式を採用
→レジスタ内容を読み出し、計算し、結果をレジスタに書き込むという流れで把握しやすいため

■データパスの構築
データパス要素→プロセッサ内でデータを処理または保持するために使用する機能ユニット
要素
・メモリユニット
→プログラムの命令を格納するとともに指定されたアドレスの命令を提供
・プログラムカウンタ(PC)
→現在の命令のアドレスを保持
・加算器(ALU)
→ＰＣを次の命令のアドレスに繰り上げる

R形式(算術系)を使用する命令の場合レジスタを2つ読み出しその内容に対してALU演算を実行し結果を書き込む。
このタイプの命令をR形式命令または算術論理演算命令と呼ぶ。

レジスタファイル＝レジスタの集合
→レジスタファイルの番号を指定することで任意のレジスタを読み書きできる。
オペランドに3つのレジスタを使用する。

■単純な実装方式
命令のタイプに応じてALUはどれかの機能を実行する必要がある。
機能は以下の通り
・ＡＮＤ
・ＯＲ
・加算
・減算
・Set on less than
・NOR

ALUでopを実装する場合ALUOpビットと機能コードの組み合わせに関する真理値表を作成する。
これを最適化してゲートを作成する。

データパスの実行過程は以下の通り
1.命令が命令メモリからフェッチされPCが繰り上げられる
2.オペラントの2つのレジスタ値がレジスタファイルから読み出される。
  このステップの間に主制御ユニットは制御線の設定をどうするか算出する
3.機能コードからALU機能を決定しレジスタファイルから読み出されたデータを操作する
4.ALUで処理した結果をレジスタファイルに書き込む

単一サイクルは効率が悪いので通常使われない。
理由はクロックサイクルが長すぎるため。

■パイプライン処理の概要
パイプライン処理は複数の命令を少しずつずらして同時並行的に実行する実装方式。
例えば洗濯を例に挙げると
1.一山の汚れた洗濯物を洗濯機に入れる
2.洗濯機が止まったらぬれている洗濯物を乾燥機に移す
3.乾燥機が止まったら乾いた洗濯物を取り出して机の上でたたむ
4.洗濯物をたたみ終えたらルームメイトに片付けてもらう。
この流れの場合、2が終わったら1を再度実施することが出来る。
つまり全ての動作が並行して動作している。
MIPSに当てはめると
1.メモリから命令をフェッチする
2.命令をデコードしながらレジスタを読み出す。
3.命令操作の実行またはアドレスの生成を行う
4.データメモリ中のオペランドにアクセスする
5.結果をレジスタに書き込む。

行間間隔は下記の通り
パイプライン処理における命令の実行間隔＝非パイプライン処理における命令の実行間隔/パイプラインのステージ数(ステップ数)

パイプライン処理は個々の命令の実行時間を短縮するわけではなく命令のスループット増加させることで性能を向上させる
MIPSは命令長が固定なのでパイプライン処理が前提で作られている。
また命令数がすくなくメモリオペランドはロードまたはストアのみ現れる制約もパイプライン処理には有利。

ハザード＝パイプライン処理において次のクロックサイクルで次の命令を実行できないこと
種類は以下
・構造ハザード
→一緒に実行される命令の組み合わせにハードウエアが対応できず所定のクロックサイクルで実行できない。
・データハザード
→他のステップが完了するのを別のステップが待つ必要があるためにパイプラインをストールさせなければならないとき、
データハザードが発生する。
データハザードとは命令の実行に必要なデータがまだ利用可能になっていない場合に起きる。

フォワーディングバイパシング＝本来なら後から行われるデータの受け渡しを内部資源から先送りするハードウエアを追加すること

・制御ハザード
→ある命令の実行に関する判断をまだ実行中のほかの命令の結果に基づいて下す必要がある場合に発生。
解決策は以下
・ストール：終わるのを定期的に確認する。
・予測：条件設定に問題ないと判断し次の命令を実施。
■データパスのパイプライン化と制御
説明上利用するデータパスの名前を以下とする
・IF：命令フェッチ
・ID：命令デコードとレジスタフェッチ
・EX：命令実行/アドレス生成
・MEM：データ・メモリ・アクセス
・WB：書き込み
基本的に時間が左から右へ動いている処理についてはハザードは起きない。
右から左へ動くもののみが起きる。

■データハザード：フォワーディングとストール
依存関係がある場合、もし仮に同一クロックサイクルでレジスタへの書き込みと読み出しが
出来れば前半で書き込みを行い後半で読み出しを行えば基本的に更新されている状態で次の
読み出しが出来るのでデータハザードは発生しない。
データハザードが発生する場合はフォワーディングで対処する。
フォワーディングは任意のレジスタからデータを読み出せるようにすることで実装可能。
フォワーディングで救えない場合はロード命令が書き込むのと同じレジスタを直後の命令が
読み出そうとするとき。
これを救うためにハザード検出ユニットが存在する。
ハザード検出ユニットではレジスタフィールドがIDステージにある命令のどちらかの
ソースレジスタと合致するかをチェックして当てはまるなら1クロックサイクルだけストールする。
その後はフォワーディング。
ストールさせるときでも何かを実行させなければならないが、
何かを実行させると次に進むため何もしないnop命令を実行させる。

■制御ハザード
改善点
・分岐が不成立であると予測して後続命令の実行を継続する
  成立していた場合は分岐まで戻って実行を継続するのでコストは半減
  今まで進んでいた分を一括削除する必要がある。
  分岐は早ければ早い方が削除するものが減る。
  そのために分岐先アドレスの計算と分岐判定の評価という
  2つの処理を早く開始する必要がある。
  予測する上で分岐が成立していたかどうかを命令のアドレスを調べて
  前回分岐が成立していれば前回と同じアドレスから新しい命令のフェッチを開始する＝動的分岐予測
  その方式の実装形態として分岐予測バッファがある。
  最近ではどの分岐が一番成立するかを記録して判断するトーナメント分岐というものもある。
■例外
制御のうち最も困難な部分が例外と割り込み。
例外が発生した場合は発生した場所や状況によって対処法が異なる。
パイプライン方式では制御ハザードのバリエーションとして対処する。

■命令を通じた並列処理
パイプライン処理は並列性を利用している＝命令レベル並列性
並列性をより引き出して活用する手法は投機実行＝予測に基づいてコンパイラやプロセッサが
                                          命令の挙動を見込んで命令の完了を待つ必要があるほかの命令の実行をいち早く開始可能にする方法。
投機実行はコンパイラでもハードウエアでもどちらに実装しても良い。
ただし本来行くはずのなかったアドレスにアクセスしてしまうことになるため
予想しない例外が発生する確率が上がる。

■誤信と落とし穴
誤信：パイプライン処理は容易である
正しく動作させることは難しい
誤信：パイプラインの設計思想は製造テクノロジと独立に実装できる
落とし穴：命令セットの設計がパイプラインに負の効果を与える場合があることを検討し忘れる
