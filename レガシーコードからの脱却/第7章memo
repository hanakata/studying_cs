第7章 プラクティス3

痛みに対処する方法は回避か順応
継続的インテグレーションとは？
リリース直前まで待つのではなくソフトウェアをビルドしながら統合すること。

プロジェクトの鼓動を確立する
継続的インテグレーション＝プロジェクトの心臓の鼓動
→すべてをバックグラウンドで行い自動で実行する。
適当なコンピュータで良いので1台用意してそれをビルドサーバにする
自動化ユニットテストを作ることは無料ではないが、一度作れば後では追加でコストがかからない。

完了と完了の完了と完了の完了の完了が違うことを知る
完了
従来のウォーターフォール開発で機能を作った開発者が自分のマシンで実行し
何らかの結果を得たことを意味する。十分ではない
完了の完了
自分のマシンだけでなくビルドにも統合されていること。
致命的な不整脈になり得るものでも迅速に検出できる。
完了の完了の完了
ビルドに統合されクリーンで保守可能になっている。
保守性は絶対に保たなくてはならない。
完了の完了の完了のみが完了となる。

継続的にデプロイ可能にする
継続的インテグレーションは本番環境へ継続的にデプロイしなければならないという意味ではない。
新しいコードをチェックインするたびに、毎回のイテレーションの最後にリリースするわけでもない。
開発の都合ではなく市場の需要、保守性の問題、デプロイ可能か、バージョン管理によって決定されるべき。
システムのビルドに必要なすべてのコードとファイルはバージョン管理の1つのリポジトリで管理する
→JSの場合はそれがすべてではないような気がする。

ビルドを自動化する
自分が見えないくらい簡単にソフトウェアをビルドできるようにするのが理想。
マウス1回クリックでビルド起動できるべき。
ビルドが遅い＝遅いテストがある
ビルドは10分で終わるべきというがそれでも遅い。
ローカルビルドは秒、サーバビルドは数分で終わらせるべき。
システム全体をビルドするのではなく依存関係を取り除いて必要なものだけビルドできるようにするべき。
インターネットに繋がらなくてもビルドは成功すべき。
壊れたビルドは即座に対処すること。

早期から頻繁に統合する
統合するのが遅れれば遅れるほど大変になる。なので常に統合する。
開発者には1日1回統合することを徹底すること。
統合回数が多ければ多いほど統合するタイミングでの変更部分は少ない。
そうすることでバグが見つけやすくなり対応も早くなる。

最初の一歩を踏み出す
開発中のソフトウェアは初日から常にリリース可能であるべき。
仮に2週間のイテレーションで開発していて統合は個人のブランチでやって
年末にすべてのブランチを統合しているならそれはウォーターフォールになっている。
システムに機能が完全に統合されるように作るべき。

アジャイルインフラストラクチャーの7つの戦略
・すべてをバージョン管理する
バージョン管理していないプロジェクトはありえない。
・ワンクリックでエンドツーエンドのビルドをする
ビルドプロセス全体を自動化する。
・継続的に統合する
スプリントごとにソフトウェアをリリースしなければならないわけではないが
それが可能である状態であることが重要。
・タスクの受け入れ基準を定義する
全てのタスクは終わったことがわかるような明確な受け入れテスト必要。
・テスト可能なコードを各
チームが自動テストに取り組めばQAにとって回帰テストで時間を無駄にする必要がなくなる。
それだけでなく開発者のアプローチがうまくいくかのフィードバックが得られる。
・必要な場所のテストカバレッジを維持する
コードを書く前にテストを書く事でテストカバレッジが維持できる
・壊れたビルドをすぐ直す
チェックインしたコードがビルドを壊したら修正するかすぐにロールバックする。

リスクを減らす7つの戦略
・継続的に統合する
初日からビルドできるようにして継続的に統合することがリスクを排除する1番の方法
・ブランチを避ける
コードがシステムに統合されればリスクはおほぼゼロになる。
・自動テストに投資する
テストが完全に自動化するために検証のための人手の介在を全て排除すること
・リスクのある場所を特定する
直接管理ができないような外部の依存性を特定しリスクを軽減すること
・未知の中で働く
未知のものを認識したら短時間だけそれに取り組みしてきとくして進捗を確認する。
・価値がわかる最小のものをつくる
問題が小さいほどほとんどのものが容易になる。
また最小にすることで価値が分かりやすくなる。
・頻繁に検証する
検証は実際に目にするまで欲しいものが分からない場合も多い。

まとめ
・コードを書くたびに統合すること
・統合が苦痛になるのでウォーターフォールでは統合を延期しリスクと変更コストが増大する。
・リリース候補の検証を自動化することでリリース直前の変更にかかるコストを無視できる
・フィードバックサイクルを短くすることで開発者の行動の結果がすぐに把握できる
・継続的にデプロイできることの重要性を理解すれば自動化や継続的インテグレーションを活用する。