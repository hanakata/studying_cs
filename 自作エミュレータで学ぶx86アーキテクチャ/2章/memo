2章 ポインタとアセンブリ言語
レジスタとは？
CPUに組み込まれている作業領域のこと
intel80386には32ビット幅の汎用レジスタが8つある。
アセンブリ言語ではeaxやespなどの名前で指定する。
アセンブリ言語の命令で何かのデータを指定する箇所ではほとんどの場合、レジスタを指定する。
割り算命令divの演算結果はeaxとedxが使われる。
アセンブリ言語ではレジスタはなくてはならないがC言語からレジスタを直接見ることはない。
C言語の場合、変数がレジスタではなくメモリに置かれることになっている。
メモリに置かれずレジスタに置かれることもあるがコンパイラがやるのでプログラマは考える必要がない。

メモリはCPUには内蔵されていない外側に接続されている部品。
データを記憶するという機能はレジスタと同じだが容量はメモリの方が大きい。
この領域にはOS本体や各種アプリケーションの実行ファイルなどが置かれる。
CPUがアクセスする際にはメモリの先頭から1バイトずつ振られた連番を使ってアクセスする。
メモリの先頭1バイトを0番目とし次が1,2,3..という形で振られている。
この連番をメモリの番地と呼ぶ。
例えば0x7c00から0x7c03の4バイトのデータを0x7a00から0x7a03へ移動する場合は
mov eax, [0x7c00]
mov [0x7a00], eax
C言語のregister指定されていない変数はメモリに置かれる。そのためregister指定されていない変数は
置かれたメモリ番地を持つはず。
&演算子を使えばメモリ番地を得ることができる。
&演算子が適用された変数は最適化によりレジスタに置かれることはない。
なのでregister宣言した変数は&演算子を適用するとコンパイルエラーになる。

lea命令（初回登場)
これはmov命令と同じように指定されたメモリ番地を計算しその結果の番地をレジスタに書き込む。
mov命令と違うのはメモリに格納された値でなくメモリ番地そのものをレジスタに書き込む。
例えば
lea eax,[ebp-8]
となっている場合はebp-8の値がeaxに書き込まれる。
[]の中に指定した式により計算した最終的な番地をレジスタに読み込むことからleaと命名されている。
例えば
void func(void){
    int val;
    int *ptr = &val;
    *ptr = 41;
}
の場合
push ebp
mov ebp,esp
sub esp,16
lea eax,[ebp-8]
mov [ebp-4],eax
mov eax, [ebp-4]
mov dword [eax],41
leave
ret
となる。ポインタ関連の処理は
lea eax,[ebp-8]
mov [ebp-4],eax
mov eax, [ebp-4]
mov dword [eax],41
で変数val（ebp-8）の番地がeaxにコピーされ
eaxの値が変数ptr(ebp-4)にコピー
変数ptrの値をeaxに呼び出し
そのeaxの値で示される4バイトのメモリ領域に41を書き込む

これから作成するエミュレータはi386の32ビットモード用の機械語プログラムが
書かれたファイルを受け取ると先頭から順に実行していくもの
エミュレータの構成部品はレジスタとメモリ。
加算器や論理演算器のエミュレートはしない。

まずエミュレータ本体を表す構造体Emulatorを定義(main.c)
構造体Emulatorは基本型変数、配列変数、ポインタ変数を含む。
eipやeflagsはCPUの特殊なレジスタを表す。
eip＝実行中の機械語が置いてあるメモリ番地を記憶するレジスタでプログラムカウンタと呼ぶこともある。
　　 命令の実行が進むごとに増えていくため
次にエミュレータ構造体を生成して初期化しファイルから機械語プログラムを読み込む処理を作成。
コマンド名はpx86で引数に機械語プログラムが格納されたファイルを指定する仕様。
流れとしては
・main関数の最初でコマンドライン引数が1つ指定されていることの確認
・create_emuでエミュレータ構造体を生成して初期化
・機械語ファイルを開きfreadでemu->memoryに読み取る。

次は機械語を実行する部分
流れは以下
・emu->memory[emu->eip]から1バイト、すなわち命令のオペコード部分を読み取りその値によって振り分け
・1つの命令を実行するたびにeipをチェックし0ならメインループを終了
　→通常のCPUには存在しないがエミュレータはプログラム終了後にレジスタの値を表示したいため

get_code8やget_sign_code8、get_code32はmemory配列の指定した番地から8ビットや32ビットの値を取得する関数
get_code32について
i386はリトルエンディアンを採用している。そのため機械語プログラムの中の多バイト値は下位バイトほど小さい番地に配置される。
なのでget_code32はfor文で1バイトを読み取るごとに8ビットずつ左にずらす処理をおこなう。

ここまででエミュレータ実装の大枠ができたので動作確認が可能となる。
確認用アセンブリ言語プログラムは以下
BITS 32
start:
    mov eax, 41
    jmp short start

BITS 32はアセンブラNASMに対して32ビットモードでアセンブルする旨を伝えるもの
startはラベル。その地点のメモリ番地に名前を付ける役目がある。
movはお馴染みでeaxへ41を代入する。
jmp short startはstartラベルへ戻る。
やり方
tolset_p86\pasm-helloworldまで言って!cons_nt.batを起動
そこでmakeするとbinファイルが作成される
エミュレータは
tolset_p86\emu2.3でmakeするとexeができる。
そのexeを使ってbinファイルを実行すると
px86.exe ..\pasm-helloworld\helloworld.bin
EIP = 0, Code = B8
EIP = 5, Code = EB


end of program.

EAX = 00000029
ECX = 00000000
EDX = 00000000
EBX = 00000000
ESP = 00007c00
EBP = 00000000
ESI = 00000000
EDI = 00000000
EIP = 00000000
プログラムが実行されレジスタの値が表示される。

ここからはポインタの復習
ポインタはメモリの番地を直接扱う仕組み。
例
void func(void){
    int val;
    int *ptr = &val;
    *ptr = 41;
}
これでvalに41が代入される。
ptrはint型変数を指すポインタを格納するためのint*型。*はポインタ型であることを示す。
*ptr = 41;でポインタが指し示している変数を間接参照することができる。
使い道として、例えばCは複数返り値を返すことができないため、
ポインタを使って関数をまたぐ形で値を渡すことができる。

ポインタはメモリ番地と指し示す先の領域の大きさを組み合わせた概念
ある型をTとしたときT*はT型のポインタを表す型となる。
T型の領域はsizeof(T)でありTによって変わるがポインタ変数はメモリ番地を格納するので
ポインタ変数自身の大きさは同じ。
アセンブリ言語の世界ではメモリ領域を読み書きする場合、番地を[]で囲む。
C言語では変数でもアセンブリ言語の世界ではメモリ番地によって領域を指し示すので
C言語のポインタに似ている。
void func(void){
    int val;
    int *ptr = &val;
    *ptr = 41;
}
これをコンパイルすると
push ebp
mov ebp,esp
sub esp,byte +0x10
lea eax,[ebp-0x8]
mov [ebp-0x4],eax
mov eax,[ebp-0x4]
mov dword [eax],0x29
leave
ret
となる。
変数valはebp-8に、変数ptrはebp-4にそれぞれ配置されている。
注目すべきはポインタ変数とint型変数はアセンブリ言語の世界では区別がない。
結局はビット列を格納したメモリ領域。
整数とポインタを使ったプログラムだとどうなるか
voic func(void){
    int *ptr;
    ptr = (int *)0x100;//キャスト演算子を使って単なる整数である0x100をint型変数の番地と意味付けしている
    *ptr = 41;
}
これをコンパイルした結果は以下。
push ebp
mov ebp,esp
sub esp,byte +0x10
mov dword [ebp-0x4],0x100
mov eax,[ebp-0x4]
mov dword [eax],0x29
leave
ret
不正なメモリ番地への書き込みに起因するエラーが発生する。
ポインタがバグやセキュリティ脆弱性に繋がりやすいのはポインタ変数に実態がないメモリ番地を設定できるから。

構造体は複数の変数をまとめて新しい型を作る機能。

ある型の変数を定義するときはその方の大きさが分かっている必要がある。
→大きさが分からないとコンパイラがどれほどのメモリを割り当てるか判断できないから。
基本型なら既に分かっているものなので問題ないが、構造体などユーザ定義型の場合は定義時点で分かる必要がある。

ただしポインタの場合はエラーにならない。
→メモリ番地の桁数はなんであれ一定だから。

中身の詳細を書かずに構造体を宣言するテクニック＝前方宣言
→ライブラリの実装詳細をユーザから隠したりヘッダファイル間の依存関係を減らすのに応用できる。
実装詳細を隠すには？
構造体の中身を読み書きするには必ず関数を使うようにする。その関数に構造体のポインタを渡す。
構造体の詳細が必要なのはその関数内のみなので隠蔽される＝カプセル化

アセンブリのサブルーチン
callで呼ばれてretで元の位置へ戻る。
