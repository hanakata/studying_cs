3章 CPUがプログラムを実行する仕組み

CPUは内蔵するプログラムカウンタ(eipレジスタ)が指すメモリ領域から機械語命令を読み取って解釈しその命令に従って動作する。
メモリ＝メインメモリのこと
ポイントはCPUはメモリに置いてあるプログラムしか実行できない。
プログラムが保存されているのは補助記憶装置。
そこから実行するための機械語プログラムはプログラムローダーによってメモリへ読み出される。
その後、プログラムローダーが読みだしたプログラムの先頭へジャンプしプログラムが実行される。

ではプログラムローダーを読み出すプログラムローダーは？
BIOS。
BIOSは不揮発性記憶装置に書き込まれているがメモリと同列に接続されているため
CPUからはメモリと同じものに見える。なのでCPUからはメモリと同じようにアクセスでき
コンピュータに電源を入れればそのまま実行できる。
機械語プログラムはさまざまな形式で補助記憶装置に保存される。
一番簡単なのは機械語プログラムそのままのバイト列を格納する方法＝Raw Binaryとか呼ばれる。
→com形式の実行可能ファイルがこの形式。
現在、WindowsならPE、MacならMach-O形式、UnixならELF形式が主流
→機械語のバイト列にヘッダを付与したファイル。
ヘッダ部には機械語のバイト数や各セクションのサイズなどの管理情報が含まれる。

どの実行ファイルの形式でも基本的にはメモリの特定の番地に配置する必要がある。
→仮にずれたところに配置するとメモリ番地を扱う命令がうまく動かなくなるから。
例えば絶対ジャンプ命令はアセンブル時に仮定した配置番地（com形式だと0x100)に従って
ジャンプ先の番地が決められているのでずれるとうまく動かない。

またラベルを使った命令も影響を受ける。

アセンブリ言語で書いたプログラムは0番地から配置しない方法もある。
先頭に記述するorg疑似命令で例えばorg 0x7c00と書くと0x7c00に配置した際、
正しく動くようになる。

現在のパソコンはマルチタスクだが？
1つのパソコンで複数のプログラムを同時に動かせるのはCPUに備わっているアドレス変換機能のおかげ。
→プログラムから見たメモリ番地とCPUがアクセスするメモリ番地を変換することで競合を避ける仕組み。
これを使うとAというプログラムは0x100000から、Bというプログラムは0x200000から配置するが
プログラムから見ると0x400000からどちらも配置されているという状況が作れる。

アドレス空間とは？
イコール番地の空間で0x00000000番地から0xffffffff番地までの全番地の集合
アドレス変換がなければプログラムがメモリを見る空間の論理アドレス空間と
CPUがメモリを見る物理アドレス空間が同じになる。
現実にはアドレス変換があるのでそれぞれの対応表をCPUが持つことになる。
個々の変換設定はセグメント名で管理される。
基本的にＯＳでアドレス変換表を管理し、作成してＣＰＵに渡す。
このアドレス変換機能＝ページングもしくはセグメンテーションと呼ぶ
物理メモリをいくつかのセグメントにわけて1つのプログラムを1つのセグメントへ格納する。
なのでプログラムの0番地はセグメントの先頭。

ページングは論理アドレス空間を小さな同じ大きさのページに分けページ単位で物理メモリを割り当てる。
普通プログラムは論理アドレス空間の中でも一部分しか使わないためいくつかのページに
物理メモリを割り当てておけば足り、アドレス空間全体を網羅する大容量の物理メモリがなくても問題ない。
プログラム的には割り当てられている感じでも実際は割り当てられてないのでメモリ容量は消費しない。

前回作成したエミュレータにorg機能を追加
今回読み込むアセンブリ言語のファイルは以下のを追加
BITS 32
    org 0x7c00
    mov eax, 41
    jmp 0

まずエミュレータが受け取った機械語ファイルをmemory配列に読み込む際、0番地ではなく0x7c00番地へ
読み込むように変更。そしてorgを付けたしたことにより0番地へのジャンプがjmp short start からjmp 0に変わる

