3章 CPUがプログラムを実行する仕組み

CPUは内蔵するプログラムカウンタ(eipレジスタ)が指すメモリ領域から機械語命令を読み取って解釈しその命令に従って動作する。
メモリ＝メインメモリのこと
ポイントはCPUはメモリに置いてあるプログラムしか実行できない。
プログラムが保存されているのは補助記憶装置。
そこから実行するための機械語プログラムはプログラムローダーによってメモリへ読み出される。
その後、プログラムローダーが読みだしたプログラムの先頭へジャンプしプログラムが実行される。

ではプログラムローダーを読み出すプログラムローダーは？
BIOS。
BIOSは不揮発性記憶装置に書き込まれているがメモリと同列に接続されているため
CPUからはメモリと同じものに見える。なのでCPUからはメモリと同じようにアクセスでき
コンピュータに電源を入れればそのまま実行できる。
機械語プログラムはさまざまな形式で補助記憶装置に保存される。
一番簡単なのは機械語プログラムそのままのバイト列を格納する方法＝Raw Binaryとか呼ばれる。
→com形式の実行可能ファイルがこの形式。
現在、WindowsならPE、MacならMach-O形式、UnixならELF形式が主流
→機械語のバイト列にヘッダを付与したファイル。
ヘッダ部には機械語のバイト数や各セクションのサイズなどの管理情報が含まれる。

どの実行ファイルの形式でも基本的にはメモリの特定の番地に配置する必要がある。
→仮にずれたところに配置するとメモリ番地を扱う命令がうまく動かなくなるから。
例えば絶対ジャンプ命令はアセンブル時に仮定した配置番地（com形式だと0x100)に従って
ジャンプ先の番地が決められているのでずれるとうまく動かない。

またラベルを使った命令も影響を受ける。

アセンブリ言語で書いたプログラムは0番地から配置しない方法もある。
先頭に記述するorg疑似命令で例えばorg 0x7c00と書くと0x7c00に配置した際、
正しく動くようになる。

現在のパソコンはマルチタスクだが？
1つのパソコンで複数のプログラムを同時に動かせるのはCPUに備わっているアドレス変換機能のおかげ。
→プログラムから見たメモリ番地とCPUがアクセスするメモリ番地を変換することで競合を避ける仕組み。
これを使うとAというプログラムは0x100000から、Bというプログラムは0x200000から配置するが
プログラムから見ると0x400000からどちらも配置されているという状況が作れる。

アドレス空間とは？
イコール番地の空間で0x00000000番地から0xffffffff番地までの全番地の集合
アドレス変換がなければプログラムがメモリを見る空間の論理アドレス空間と
CPUがメモリを見る物理アドレス空間が同じになる。
現実にはアドレス変換があるのでそれぞれの対応表をCPUが持つことになる。
個々の変換設定はセグメント名で管理される。
基本的にＯＳでアドレス変換表を管理し、作成してＣＰＵに渡す。
このアドレス変換機能＝ページングもしくはセグメンテーションと呼ぶ
物理メモリをいくつかのセグメントにわけて1つのプログラムを1つのセグメントへ格納する。
なのでプログラムの0番地はセグメントの先頭。

ページングは論理アドレス空間を小さな同じ大きさのページに分けページ単位で物理メモリを割り当てる。
普通プログラムは論理アドレス空間の中でも一部分しか使わないためいくつかのページに
物理メモリを割り当てておけば足り、アドレス空間全体を網羅する大容量の物理メモリがなくても問題ない。
プログラム的には割り当てられている感じでも実際は割り当てられてないのでメモリ容量は消費しない。

前回作成したエミュレータにorg機能を追加
今回読み込むアセンブリ言語のファイルは以下のを追加
BITS 32
    org 0x7c00
    mov eax, 41
    jmp 0

まずエミュレータが受け取った機械語ファイルをmemory配列に読み込む際、0番地ではなく0x7c00番地へ
読み込むように変更。そしてorgを付けたしたことにより0番地へのジャンプがjmp short start からjmp 0に変わる
現在実装されているものはショートジャンプと呼ばれるもので8ビット符号付整数をeipの差分として使うことで
現在位置から-127～128までの範囲でジャンプできる。
今回は0x7c00にジャンプ命令が書かれているので0番地まで届かない。
なので32ビットの符号付き整数を取る相対ジャンプ命令であるニアジャンプを利用する。
ニアジャンプはオペランドのビット数が違うだけで動作はショートジャンプと同じ。

org 0x7c00に対応するためには機械語プログラムの読み込み先とeipの初期値も替える必要がある。

プログラムを実行するためにメインメモリに配置した。
ではその配置したプログラムをCPUが実行する過程は？
過程は大きく分けて3つ
フェッチ＝メインメモリから命令を読み込む
デコード＝命令を解釈する
実行

CPUは現在実行中のメモリ番地を格納するレジスタや計算用のデータを一時保存するレジスタを持つ。
レジスタは汎用的に使うこともできるが、得意不得意もあるのでうまく使い分けると高速に実行出来たりする。
また使う役割が明確になっているものもある、espとか。
これは計算に使われることはめったにない。
レジスタ幅は全て32ビットだが一部分に別名がついている。
eax、ebx、ecx、edxの4つは下位16ビットにax、bx,cx,dxという名前がついており
下位16ビットのうち下位8ビットにはcl,dlのような名前がついている。
汎用的にレジスタは使えるが以下の特殊レジスタは特定の役割がある。
eip・・・現在実行中の命令の番地を記憶する
→フェッチや実行の過程に直接関係してくる
eflags・・・演算結果やCPUの状態などを表す
→計算結果の補助的な情報、繰り下がり、繰り上がりとか計算結果が0になったとか
これを使って分岐処理が作成できる。

CPUはレジスタ以外にも演算処理を行う加算器や論理演算器を持つ。
加算器は加算や減算、インクリメント、デクリメントなどの算術演算で使う。
条件分岐命令直前に使うcmp命令も加算器を利用する。
CPUと周辺機器やメモリとの関係はアドレスバスとデータバスで繋がっている。
アドレスバスはCPUがどの装置の何番地を読み書きするかの指示、
データバスは実際のデータが流れる。

一般的なPC/AT互換機では0xa0000から0xaffffまでの領域は特殊なメモリであるVRAMに接続されており
その範囲への書き込みはディスプレイ表示に影響を与える。

CPUはeipレジスタに格納された番地のメモリ領域から機械語命令のバイト列を読み取り（フェッチ）
読み取った命令を解釈し（デコード）実行する。（実行）

今度はModR/Mの導入
ModR/Mが使えるとメモリとレジスタの間で値を操作する命令を実装できる。
今後のことも考えてEmulator構造体の定義をemulator.hに、エミュレータのメモリやレジスタを使うための
関数群をemulator_function.h/.cに、機械語命令の実装をinstruntion.h/.cに分割する。

ソースコード分割の基本
対応する.hと.cをつくり
.hに関数プロトタイプ宣言や構造体の定義、グローバル変数のextern宣言を書く
.cに関数本体の定義やグローバル変数の定義を置く。
→.hファイルは複数の.cファイルから犬ルードされる可能性があり、.hに実態の定義を書いてしまうと
それが呼ばれるたびに実態が定義されてしまうため
分割に大事なことの2つめは.hファイルにインクルードガードという.hファイルの2重インクルードを防ぐ仕組みを付けること。

今までみてきたmov、add、incなどの命令は上から順番に実行される順次実行命令
これらの命令はeipレジスタを変更することがないのでプログラムの流れも変えない。
CPUの命令のほとんどは順次命令だがeipを書き換えてプログラムの流れを変える分岐命令もある。
例えばret、jmpがある。これらはeipを書き換える命令。

まずはjmp
jmpはオペランドに指定したメモリ番地をeipに書き込む（加算する）ことによって任意の番地にジャンプする命令。
jmp命令が実行されると必ずeipが書き換わるので無条件分岐命令とも呼ぶ。
何らかの条件を満たしたときにジャンプする命令は条件分岐命令と呼ぶ。
以下のコードをコンパイルすると
int abs(int i){
    if (i >= 0){
        return i;
    }else{
        return -i;
    }
}
コンパイル結果
00000000    55          push ebp
00000001    89E5        mov ebp,esp
00000003    837D0800    cmp dword [ebp+0x8],byte +0x0
00000007    7805        js 0xe
00000009    8B4508      mov eax,[ebp+0x8]
0000000C    EB05        jmp short 0x13
0000000E    8B4508      mov eax,[ebp+0x8]
00000011    F7D8        neg eax
00000013    5D          pop ebp
00000014    C3          ret

else節をスキップするためにjmp命令がある。
mov eax,[ebp+0x8]がif節の内容。
これが成立すると0x09が実行され0x13番地まで飛ぶ。
0x0eと0x11番地がelse節でneg命令が-iの計算に対応している。

今回のjmp命令は現在位置からの相対番地を指定する相対ジャンプ命令。
0xebがオペコードで0x05が相対番地。
次の命令が0x0e番地にあるので0x0e+0x05で0x13となり13番地にジャンプできる。
もうひとつジャンプ命令がありjsがそれにあたる。
これは特定の条件が満たされるときにジャンプする。

スタックとは？
→値を積み上げて記憶しておき後で上から順に取り出すようなデータ構造のこと
x86アーキテクチャではメモリの一部をスタック構造として使う。
x86CPUにはespという名のスタックポインタというレジスタがありスタックの先頭番地を保持する
役目を持つ。プッシュ、ポップするたびに最新位置は変わっていく。
pushの動きは
1.espを4だけ減少させる
2.espが指すメモリ領域にオペランドを書き込む
popの動きは
1.espが指すメモリ領域から値を読み取ってオペランドに書きこむ
2.espを4だけ増加させる

スタック構造はプッシュするたびに大きくなる
なのでプッシュし続けると再現なく成長しそのうち破壊してはいけないメモリ領域に達する。
それがスタックオーバーフロー

call/ret命令
call/retはサブルーチンを呼び出したり元の場所に戻る命令
callはメモリのとある場所に実行中のメモリ番地をメモしてからサブルーチンにジャンプし
retはメモした値を取り出して元の場所に戻る。
このメモをするのに使う場所がスタック。
call メモリ番地と書くことで現在のeipの値をスタックにプッシュしさらにジャンプ先のメモリ番地をeipに書き込む。

retはcallと対として使う。
retはスタックから4バイトの値をポップしその値をeipにセットする。
正しくプログラムが組まれていればスタックの先頭にはcall命令よりプッシュされた戻り先のメモリ番地が書いてあるはずなので
retの直後に正しく元の場所へ戻ることができる。

pushとpopの回数がずれていたりスタックの値が上書きされていたりするとpopした値が正しいメモリ番地ではないので
その結果プログラムが暴走する。
それがスタックオーバーフロー攻撃

C言語の関数呼び出しはcall/retを使うがサブルーチンと違うのは引数と戻り値があること
・サンプルコード
int my_add(int a, int b)
{
    return a + b;
}

void func(void)
{
    int v = my_add(3,5);
}
・コンパイル結果
00000000    55          push ebp
00000001    89E5        mov ebp,esp
00000003    8B5508      mov edx,[ebp+0x8] //第1引数をedxへ
00000006    8B450C      mov eax,[ebp+0xc] //第2引数をeaxへ
00000009    01D0        add eax,edx //第1引数と第2引数を足す
0000000B    5D          pop ebp
0000000C    C3          ret
0000000D    55          push ebp
0000000E    89E5        mov ebp,esp
00000010    83EC10      sub esp,byte +0x10
00000013    6A05        push byte +0x5
00000015    6A03        push byte +0x3
00000017    E8E4FFFFFF  call 0x100000000
0000001C    83C408      add esp,byte +0x8
0000001F    8945FC      mov [ebp-0x4],eax　//変数vへの書き込み
00000022    C9          leave　//スタックフレームの破棄
00000023    C3          ret

引数の受け渡しは関数を呼び出す側がスタックに引数をプッシュしてから関数を呼び出し、
関数の中ではスタックから値を読み取ることで実現される。
0x00からox0Cまでがmy_add関数、0x0dから0x23までがfunc関数。
第一引数が[ebp+0x8]から読みだされているのは1行目のpush ebpした影響でespの値が4減ってるから。
push ebpとmov ebp,espは関数の中で別の関数を呼ばれたときに必要な機能。
関数の先頭でebpを保存してその時点のespをebpに設定し
関数を終了する直前で保存していたebpを復元させることで正しく復帰できる。

関数を呼び出すごとに引数領域、戻り番地、ebpの保存領域、ローカル変数領域からなる
大きなメモリ領域が生成される。
→これをスタックフレームと呼ぶ。スタックフレームは関数が呼び出されるとスタックに積まれ、
関数が終了すると削除される。
この削除を簡単にするのがebpの役割。
保存されたebpは1つ手前のスタックフレームの先頭を指している。
そして現在のebpはespの初期値を保存している。
なので、mov esp,ebpしてからpop ebpするだけでスタックフレームが破棄できる。
leaveはこの2つをまとめてやる命令。

次に戻り値。
C言語の関数では引数はいくつでも渡せるのに戻り値が1つであるのはなぜか？
→レジスタは数に限りがあるため引数には利用しないが戻り値にはeaxを利用すると決まっている。

次にローカル変数。
ローカル変数はメモリ上のどこに置かれるかは規定されていない。
なのでスタックフレームに置かれることが多い。
ローカル変数＝関数内で定義された自動変数
ローカル変数をスタックフレームに置くことの利点
1.ローカル変数は関数を抜けると破棄しなくてはならない。
　なのでスタックフレーム破棄のタイミングで一緒に破棄してくれれば実装が楽。
2.関数の中からその関数を再帰的に呼び出すとき同時にスタックフレームを積むので
　上書きの心配がない。

sub esp,byte +0x10 //espから16引く
これでローカル変数の領域確保
これを実行することでpushで上書きされることなく使うことが可能な範囲が16byte用意される。
そのためその分ローカル変数で利用できる＝領域確保となる。

valだけなのになぜ16byte必要か？
アライメントの関係。
基本的にx386CPUでは4の倍数であるbyte数で領域確保した方が効率がよくなる。
longで8byte程度確保する必要性があることから16byteの領域を一旦確保する。

条件分岐命令
ある条件でのみ分岐する命令＝条件分岐命令
CF=キャリーフラグ：add/subで最上位ビットで繰り上がり/繰り下がりが発生した場合1となる
ZF=ゼロフラグ：演算結果が0なら1となる
SF=符号フラグ：演算結果の最上位ビットがコピーされる
OF=オーバーフローフラグ：符号付き演算で格納先レジスタが表せれる範囲を超えた場合1となる。
x386CPUにはeflagsというレジスタがある。
フラグレジスタとも呼ばれ1か0かを表すフラグがいくつも集まったレジスタ。
eflagsは算術理論演算命令の実行結果に合わせて変更される。
条件分岐命令は各フラグの状態に応じてジャンプするしないを判断する。
条件分岐の意味はsubと組み合わせた時に正しい場合ジャンプするように作られている。
ただsubを使うとオペランドが変更されてしまうので比較する場合はcmpを利用する。

プログラムの繰り返しという命令のないアセンブリの場合、whileやforはどうなるか？
int sum(int a, int b)
{
    int sum;
    sum = 0;
    while (a <= b){
        sum += a;
        a++;
    }
    return sum;
}

これをコンパイルすると
00000000    55              push ebp
00000001    89E5            mov ebp,esp
00000003    83EC10          sub esp,byte +0x10
00000006    C745FC00000000  mov dword [ebp-0x4],0x0
0000000D    EB09            jmp short 0x18
0000000F    8B4508          mov eax,[ebp+0x8] //aの値を
00000012    0145FC          add [ebp-0x4],eax //sumに加算
00000015    FF4508          inc dword [ebp+0x8]
00000018    8B4508          mov eax,[ebp+0x8] //eaxにaの値を読み込む
0000001B    3B450C          cmp eax,[ebp+0x8] //bの値と比較
0000001E    7EEF            jng 0xf //eaxがbより大きくない場合0xfにジャンプ
00000020    8B45FC          mov eax,[ebp-0x4]
00000023    C9              leave
00000024    C3              ret

デバイスアクセス
デバイスアクセスといえばキーボード、ディスプレイなど
やりとりはそれぞれI/Oポートを利用して。
現在のエミュレータにはCPUとメモリしかなくI/Oポートがない。
＝外界とのデータのやり取りができない。
そのためin/out命令でデータをやり取りできる仮想的な入出力装置を作成する。

装置の仕様はinでキーボードから1文字入力、outで1文字出力
全体の仕組みはin/outのオペランドに指定された番地が0x03f8番地だったら文字の入出力機能を実装したC言語の関数を呼び出す
呼び出されたらgetchar/putcharを利用して入出力。
